- 类组件和函数组件首字母要大写

- React通过首字母来判断自定义组件（大写）还是原生DOM（小写）

- props、state的改变才会引起视图更新

- setState 

  类组件中传对象不会覆盖，而是和老对象合并。但函数组件会覆盖

  更新是异步的

- 每次渲染都是独立的闭包

- 凡是带use的都有一个特征，在多次渲染的时候可能保持一致

### useMemo

**`React.memo`：** 它是一个高阶组件，用于封装函数组件，使其在只有在其 props 发生变化时才重新渲染。默认情况下，函数组件在每次父组件重新渲染时都会重新执行，但使用 `React.memo` 可以避免不必要的渲染。

### useState

1. 参数可以是一个函数，此函数会在初次渲染的时候执行，而且只执行一次。
2. 如果传入更新函数的对象是老状态对象的话，则会跳过组件更新和渲染，这是一个性能优化。

3. 不能在if while for中调用useState, 只能在函数的最外层调用hook

### useEffect

1. useEffect里面的函数会在组件挂载完成后，和组件更新完成后执行

2. 如果第2个参数没传，则此函数每次渲染都会执行
3. 如果传的是一个空数组，只会在第一次挂载后执行一次，以后不再执行了

### useRef

1. useRef返回一个可变的ref对象， 其 `.current`属性被初始化为传入的参数。
2. 被引用对象的值在重新渲染之间保持不变

### useLayoutEffect

1. 数据改变后, render(渲染) layout(布局)， 再执行useLayoutEffect，然后再paint(绘制到屏幕上)，然后再在某个空闲的时间点执行useEffect
2. 会阻塞渲染
3. 总结：
- 何时使用useEffect
  副作用与DOM无关：例如，数据获取、设置订阅、手动更改浏览器的URL等。
  不需要立即同步读取或更改DOM：如果你不关心可能的微小布局跳动或闪烁，那么useEffect就足够了。
  性能考虑：useEffect通常对性能影响较小，因为它不会阻塞浏览器渲染。
- 何时使用useLayoutEffect
  作用于这样的场景：需要在浏览器绘制前获取 DOM 元素的大小或位置，或者在浏览器绘制前修改 DOM
  需要同步读取或更改DOM：例如，你需要读取元素的大小或位置并在渲染前进行调整。
  防止闪烁：在某些情况下，异步的useEffect可能会导致可见的布局跳动或闪烁。例如，动画的启动或某些可见的快速DOM更改。
  模拟生命周期方法：如果你正在将旧的类组件迁移到功能组件，并需要模拟 componentDidMount、componentDidUpdate和componentWillUnmount的同步行为。
- 使用注意事项
  避免过度使用useLayoutEffect，因为它是同步的，可能会影响应用的性能。只有当你确实需要同步的DOM操作时才使用它。
  如果代码在服务器端渲染（SSR）中出现问题，考虑回退到useEffect。useLayoutEffect在服务器端渲染时不会运行，可能会引发警告或错误。

### forwardRef + useImperativeHandle
